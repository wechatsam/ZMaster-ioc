{"version":3,"sources":["assets\\Script\\src\\network\\base\\JTWebSocket.ts"],"names":[],"mappings":"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","file":"","sourceRoot":"/","sourcesContent":["\r\n\r\nnamespace com \r\n{\r\n/**\r\n * <p> <code>Socket</code> 封装了 HTML5 WebSocket ，允许服务器端与客户端进行全双工（full-duplex）的实时通信，并且允许跨域通信。在建立连接后，服务器和 Browser/Client Agent 都能主动的向对方发送或接收文本和二进制数据。</p>\r\n * <p>要使用 <code>Socket</code> 类的方法，请先使用构造函数 <code>new Socket</code> 创建一个 <code>Socket</code> 对象。 <code>Socket</code> 以异步方式传输和接收数据。</p>\r\n */\r\n    export class JTWebSocket extends JTEventDispatcher {\r\n        /**\r\n         * <p>主机字节序，是 CPU 存放数据的两种不同顺序，包括小端字节序和大端字节序。</p>\r\n         * <p> LITTLE_ENDIAN ：小端字节序，地址低位存储值的低位，地址高位存储值的高位。</p>\r\n         * <p> BIG_ENDIAN ：大端字节序，地址低位存储值的高位，地址高位存储值的低位。有时也称之为网络字节序。</p>\r\n         */\r\n        static LITTLE_ENDIAN: string = \"littleEndian\";\r\n        /**\r\n         * <p>主机字节序，是 CPU 存放数据的两种不同顺序，包括小端字节序和大端字节序。</p>\r\n         * <p> BIG_ENDIAN ：大端字节序，地址低位存储值的高位，地址高位存储值的低位。有时也称之为网络字节序。</p>\r\n         * <p> LITTLE_ENDIAN ：小端字节序，地址低位存储值的低位，地址高位存储值的高位。</p>\r\n         */\r\n        static BIG_ENDIAN: string = \"bigEndian\";\r\n        _endian: string;\r\n        protected _socket: any;\r\n        private _connected: boolean;\r\n        private _addInputPosition: number;\r\n        private _input: any;\r\n        private _output: any;\r\n\r\n        /** 定义 open 事件对象的 type 属性值。*/\r\n        static OPEN: string = \"open\";\r\n        /** 定义 message 事件对象的 type 属性值。*/\r\n        static MESSAGE: string = \"message\";\r\n        /** 定义 close 事件对象的 type 属性值。*/\r\n        static CLOSE: string = \"close\";\r\n        /** 定义 error 事件对象的 type 属性值。*/\r\n        static ERROR: string = \"error\";\r\n\r\n        /**\r\n         * 不再缓存服务端发来的数据，如果传输的数据为字符串格式，建议设置为true，减少二进制转换消耗。\r\n         */\r\n        disableInput: boolean = false;\r\n        /**\r\n         * 用来发送和接收数据的 <code>Byte</code> 类。\r\n         */\r\n        private _byteClass: new () => any;\r\n        /**\r\n         * <p>子协议名称。子协议名称字符串，或由多个子协议名称字符串构成的数组。必须在调用 connect 或者 connectByUrl 之前进行赋值，否则无效。</p>\r\n         * <p>指定后，只有当服务器选择了其中的某个子协议，连接才能建立成功，否则建立失败，派发 Event.ERROR 事件。</p>\r\n         */\r\n        protocols: any = [];\r\n\r\n        /**\r\n         * 缓存的服务端发来的数据。\r\n         */\r\n        get input(): any {\r\n            return this._input;\r\n        }\r\n\r\n        /**\r\n         * 表示需要发送至服务端的缓冲区中的数据。\r\n         */\r\n        get output(): any {\r\n            return this._output;\r\n        }\r\n\r\n        /**\r\n         * 表示此 Socket 对象目前是否已连接。\r\n         */\r\n        get connected(): boolean {\r\n            return this._connected;\r\n        }\r\n\r\n        /**\r\n         * <p>主机字节序，是 CPU 存放数据的两种不同顺序，包括小端字节序和大端字节序。</p>\r\n         * <p> LITTLE_ENDIAN ：小端字节序，地址低位存储值的低位，地址高位存储值的高位。</p>\r\n         * <p> BIG_ENDIAN ：大端字节序，地址低位存储值的高位，地址高位存储值的低位。</p>\r\n         */\r\n        get endian(): string {\r\n            return this._endian;\r\n        }\r\n\r\n        set endian(value: string) {\r\n            this._endian = value;\r\n            if (this._input != null) this._input.endian = value;\r\n            if (this._output != null) this._output.endian = value;\r\n        }\r\n\r\n        /**\r\n         * <p>创建新的 Socket 对象。默认字节序为 Socket.BIG_ENDIAN 。若未指定参数，将创建一个最初处于断开状态的套接字。若指定了有效参数，则尝试连接到指定的主机和端口。</p>\r\n         * @param host\t\t服务器地址。\r\n         * @param port\t\t服务器端口。\r\n         * @param byteClass\t用于接收和发送数据的 Byte 类。如果为 null ，则使用 Byte 类，也可传入 Byte 类的子类。\r\n         * @param protocols\t子协议名称。子协议名称字符串，或由多个子协议名称字符串构成的数组\r\n         */\r\n        constructor(host: string|null = null, port: number = 0, byteClass: new () => any = null, protocols: any[]|null = null) {\r\n            super();\r\n            this._byteClass = byteClass ? byteClass : JTBuffer;\r\n            this.protocols = protocols;\r\n            this.endian = JTWebSocket.BIG_ENDIAN;\r\n            if (host && port > 0 && port < 65535) this.connect(host, port);\r\n        }\r\n\r\n        /**\r\n         * <p>连接到指定的主机和端口。</p>\r\n         * <p>连接成功派发 Event.OPEN 事件；连接失败派发 Event.ERROR 事件；连接被关闭派发 Event.CLOSE 事件；接收到数据派发 Event.MESSAGE 事件； 除了 Event.MESSAGE 事件参数为数据内容，其他事件参数都是原生的 HTML DOM Event 对象。</p>\r\n         * @param host\t服务器地址。\r\n         * @param port\t服务器端口。\r\n         */\r\n        connect(host: string, port: number): void {\r\n            var url: string = \"ws://\" + host + \":\" + port;\r\n            this.connectByUrl(url);\r\n        }\r\n\r\n        /**\r\n         * <p>连接到指定的服务端 WebSocket URL。 URL 类似 ws://yourdomain:port。</p>\r\n         * <p>连接成功派发 Event.OPEN 事件；连接失败派发 Event.ERROR 事件；连接被关闭派发 Event.CLOSE 事件；接收到数据派发 Event.MESSAGE 事件； 除了 Event.MESSAGE 事件参数为数据内容，其他事件参数都是原生的 HTML DOM Event 对象。</p>\r\n         * @param url\t要连接的服务端 WebSocket URL。 URL 类似 ws://yourdomain:port。\r\n         */\r\n        connectByUrl(url: string): void {\r\n            if (this._socket != null) this.close();\r\n\r\n            this._socket && this.clean();\r\n\r\n            if (!this.protocols || this.protocols.length == 0) {\r\n                this._socket = new WebSocket(url);\r\n            } else {\r\n                this._socket = new WebSocket(url, this.protocols);\r\n            }\r\n\r\n            this._socket.binaryType = \"arraybuffer\";\r\n\r\n            this._output = new this._byteClass();\r\n            this._output.endian = this.endian;\r\n            this._input = new this._byteClass();\r\n            this._input.endian = this.endian;\r\n            this._addInputPosition = 0;\r\n\r\n            this._socket.onopen = (e: any) => {\r\n                this._onOpen(e);\r\n            };\r\n            this._socket.onmessage = (msg: any): void => {\r\n                this._onMessage(msg);\r\n            };\r\n            this._socket.onclose = (e: any): void => {\r\n                this._onClose(e);\r\n            };\r\n            this._socket.onerror = (e: any): void => {\r\n                this._onError(e);\r\n            };\r\n        }\r\n\r\n        /**\r\n         * 清理Socket：关闭Socket链接，关闭事件监听，重置Socket\r\n         */\r\n        clean(): void {\r\n            this.close();\r\n            this._connected = false;\r\n            this._socket.onopen = null;\r\n            this._socket.onmessage = null;\r\n            this._socket.onclose = null;\r\n            this._socket.onerror = null;\r\n            this._socket = null;\r\n            this.removes();\r\n        }\r\n\r\n        /**\r\n         * 关闭连接。\r\n         */\r\n        close(): void {\r\n            if (this._socket != null) {\r\n                try {\r\n                    this._socket.close();\r\n                } catch (e) {\r\n                }\r\n            }\r\n        }\r\n\r\n        /**\r\n         * @private\r\n         * 连接建立成功 。\r\n         */\r\n        protected _onOpen(e: any): void {\r\n            this._connected = true;\r\n            this.dispatchEvent(JTWebSocket.OPEN, e);\r\n        }\r\n\r\n        /**\r\n         * @private\r\n         * 接收到数据处理方法。\r\n         * @param msg 数据。\r\n         */\r\n        protected _onMessage(msg: any): void {\r\n            if (!msg || !msg.data) return;\r\n            var data: any = msg.data;\r\n            if (this.disableInput && data) {\r\n                this.dispatchEvent(JTWebSocket.MESSAGE, data);\r\n                return;\r\n            }\r\n            if (this._input.length > 0 && this._input.bytesAvailable < 1) {\r\n                this._input.clear();\r\n                this._addInputPosition = 0;\r\n            }\r\n            var pre: number = this._input.pos;\r\n            !this._addInputPosition && (this._addInputPosition = 0);\r\n            this._input.pos = this._addInputPosition;\r\n\r\n            if (data) {\r\n                if (typeof (data) == 'string') {\r\n                    this._input.writeUTFBytes(data);\r\n                } else {\r\n                    this._input.writeArrayBuffer(data);\r\n                }\r\n                this._addInputPosition = this._input.pos;\r\n                this._input.pos = pre;\r\n            }\r\n            this.dispatchEvent(JTWebSocket.MESSAGE, data);\r\n        }\r\n\r\n        /**\r\n         * @private\r\n         * 连接被关闭处理方法。\r\n         */\r\n        protected _onClose(e: any): void {\r\n            this._connected = false;\r\n            this.dispatchEvent(JTWebSocket.CLOSE, e)\r\n        }\r\n\r\n        /**\r\n         * @private\r\n         * 出现异常处理方法。\r\n         */\r\n        protected _onError(e: any): void {\r\n            this.dispatchEvent(JTWebSocket.ERROR, e)\r\n        }\r\n\r\n        /**\r\n         * 发送数据到服务器。\r\n         * @param\tdata 需要发送的数据，可以是String或者ArrayBuffer。\r\n         */\r\n        send(data: any): void {\r\n            this._socket.send(data);\r\n        }\r\n\r\n        /**\r\n         * 发送缓冲区中的数据到服务器。\r\n         */\r\n        flush(): void {\r\n            if (this._output && this._output.length > 0) {\r\n                var evt: any;\r\n                try {\r\n                    this._socket && this._socket.send(this._output.__getBuffer().slice(0, this._output.length));\r\n                } catch (e) {\r\n                    evt = e;\r\n                }\r\n                this._output.endian = this.endian;\r\n                this._output.clear();\r\n                if (evt) this.dispatchEvent(JTWebSocket.ERROR, evt);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\n"]}